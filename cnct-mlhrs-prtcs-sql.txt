1)Conceitos e melhores práticas com banco de dados PostgreSQL

a) Fundamentos de Banco de Dados

O que são dados?
Valores brutos, fatos brutos, observações documentadas, registros
soltos, que são recolhidos e armazenados sem sofrer qualquer
tratamento.

O que são informações?
Estruturação de dados,organização de dados.Conjunto de dados
relacionados entre si que geram valor, que criam sentidos aos
dados.Material do conhecimento.

2002 - dado - sem valor, significado.
2002 é o ano em que... - informações 

Modelos relacionais

modelar - criar modelo que explique as características de funcionamento/o
comportamento do software.No nosso caso,modelo de dados.

Definição
Mdelo mais comum, q8ue classifica e organiza as informações em tabelas com
linhas e colunas.As linhas, ou tuplas, são os dados organizados, são os
valores das tabelas, e as colunas são os atributos destes dados.

Nós entendemos tabelas,mas para um computador a interpretação é diferente,
de forma que só assim:

telefone.1=proprietarios.1 ele entende

Tabelas
Conjuntos de dados dispostos em colunas e linhas referentes a um
objeto comum.As colunas são consideradas como "campos" da tabela,
como atributos da tabela.As linhyas são chamadas também de tuplas,
e é onde estão contidos os valores,os dados.  
 

O que pode ser definido como tabela?
-Coisas tangíveis
  - Elementos físicos(carro,veículo,produto,animal)
-Funções
  - Perfis de usuário,status de compra.
-Eventos ou ocorrencias
  -Produtos de um pedido, histórico de dados.

Colunas Importantes
-Chave Primária / Primary Key / PK
  - Conjunto de um ou mais campos que nunca se repetem.Identidade
    da tabela.São utilizados como índice de referencia na criação de
    relacionamentos entre tabelas.
-Chave Estrangeira / Foreign Key / FK
  - Valor de referencia a uma PK de outra tabela ou da mesma tabela 
    para criar um relacionamento entre tabelas.


Sistema de gereciamento d banco de dados
Ou Sistemas de gestão de base de dados.Chamamos pela sigla SGBD.
Conjunto de programas ou softwares responsáveis pelo gerenciamento
de um banco de dados.
Programas que facilitam a administração de um bd. 
Exemplo de programas:
MongoDB, MySQL, PostgreSQL, IBM DB2 e etc.
Introdução ao PostgreSQL
O que é o PostgreSQL?
Sistema de gerenciamento de banco de dados objeto relacional.

Teve início no Departamento de Ciencia da Computação na 
Universidade da Califórnia em Berkeley em 1986.

SGBD Opensource

Opensource/código aberto
pode ser utilizado, modificado e distribuído pra qualquer
pessoa com qualquer finalidade.
 

Arquitetura multiprocessos
(acontece muuuiiita coisa por trás)

Modelo cliente/servidor (do Postgre)
Tenho processos que acontecem só na máquina cliente ou só no servidor.
Os do servidor são os exibidos anteriormente, e os do cliente são
a interface gráfica pra fazer a conexão com o bd,terminal,unix,
aplicação web ou mobile enviando comandos pro bd e etc.


Pinrcipais características
-Opensource
-Point in time recovery
-Linguagem procedural(SQL) com suporte a várias linguagens de progrmç
(perl, python, etc)
-Views, functions, procedures, triggers
-Consultas complexas e Common table expressions (CTE)
-Suporte a dados geográficos(PosyGIS)
-Controle de concorrencia multi-versão

Instalação e documentação do PostgreSQL

Site oficial:
https://www.postgresql.org/
Download com instruções passo a passo:
https://www.postgresql.org/download/
Documentação completa:
https://www.postgresql.org/docs/manuals/

e d) feito

-----------------------------------------------------------------
//dia 05/07

2)Objetos e tipos de dados do PostgreSQL

a) O que é o arquivo postgresql.conf

arquivo postgresql.conf

Definição 
Arquivo onde estão definidas e armazenadas todas as 
configurações do servidor PostgreSQL.
Akguns parametros só podem ser alterados com a reinicializa-
_ção do banco de dados.
A view pg-settings, acessada por dentro do banco de dados,
guarda todas as configurações atuais.

SELECT name, setting
FROM pg_settings;

Ou é possível utilizar o comando

SHOW[parametro];

Localização do arquivo postgresql.conf
Por padrão, encontra-se dentro do diretório PGDATA definido
no momento da inicialização do cluster de banco de dados.

No sistema operacional Ubuntu, se o PostgreSQL foi instalado
a partir do repositório oficial, o local do arquivo 
postgresql.conf será diferente do diretório de dados.

/etc/postgresql/[versão]/[nome do cluster]/postgresql.conf 

Configurações de conexão

- LISTEN_ADRESSES
  Endereço(s) TCP/IP das interfaces que o servidor PostgreSQL
vai escutar/liberar conexões.
- PORT
  A porta TCP que o servidor PostgreSQL vai ouvir.O padrão é
5432.
- MAX_CONNECTIONS
  Número máximo de conexões simultaneas no servidor PostgreSQL.
- SUPERUSER_RESERVED_CONNECTIONS
  Número de conexões (slots) reservadas para conexões ao banco
de dados de super usuários
- AUTHENTICATION_TIMEOUT
   Tempo máximo em segundos para o cliente conseguir uma conexão
com o servidor.
- PASSWORD_ENCRYPTION
   Algoritmo de criptografia para senhas dos novos usuários 
criados no banco de dados.
- SSL
  Habilita a conexão criptografada por SSL
  (Somente se o  PostgreSQL foi compilado com suporte SSL) 

Configurações de memória

- SHARED_BUFFERS
  Tamanho da memória compartilhada do servidor PostgreSQL para
cache/buffer de tabelas, índices e demais relações.
- WORK_MEM (memória separadinha)
  Tamanho da memória para operações de agrupamento e ordenação
(ORDER BY, DISTINCT, MERGE JOINS).
- MAINTENANCE_WORK_EM (operações administrativas)
  Tamanho da memória para operações como VACUUM,INDEX,ALTER,
TABLE.

Obs: não coloque * em um servidor em produção,pois isso permite
que qualquer um acesse e prejudica a segurança.No caso de 
estar em testes eu posso 
colocar o *.

listen_adresses = 'local host' (padrão)
listen_adresses = '*' (não pode)

O arquivo pg_hba.conf

Definição
Arquivo responsável pelo controle de autentificação dos
usuários no servidor PostgreSQL.
O formato do arquivo pode ser:

local     database user auth-method   [auth-options]
host      database user adress      auth-method  [auth-options]
hostssl   database user adress      auth-method  [auth-options]
hostnossl database user adress      auth-method  [auth-options]
host      database user IP-adress   IP-mask       auth-method    [auth-options]
hostssl   database user IP-adress   IP-mask       auth-method    [auth-options]
hostnossl database user IP-adress   IP-mask       auth-method    [auth-options] 

(tem mais ao lado ->)

auth-method(forma de autenticação)
auth-options(opções de autenticação)

host - endereço de onde vem a conexão
hostssl - desde que aquele endereço esteja usando o ssl
hostnossl - não requisita cnexão criptografada.

Métodos de autenticação
- TRUST (conexão por requisição de senha)
- REJECT (rejeitar conexões)
- MD5 (criptografar md5)
- PASSWORD (senha sem criptografia)
- GSS (generic security service application program interface)
- SSPI (security support provider interface - somente para 
Windows)
- KRB5(kerberos V5)
- IDENT(utiliza o usuário do sistema operacional do cliente via
ident server)
- PEER(utiliza o usuário do sistema operacional do cliente)
- LDAP(Idao server)
- RADIUS(radius server)
- CERT(autenticação via certificado ssl do cliente)
- PAM(pluggable authentication modules.O usuário precisa estar
no )

//dia 07/07

O arquivo pg_ident.conf

Definição
Arquivo responsável por mapear os usuários do sistema operacional
com os usuários do banco de dados.
Localizado no diretório de dados PGDATA da sua instalação.
A opção ident deve ser utilizada no arquivo pg_hba.conf.

Ident cria mapeamentos, funciona como:

# MAPNAME SYSTEM-USERNAME PG-USERNAME
diretoria daniel          pg_diretoria
comercial tiburcio        pg_comercial
comercial valdeci         pg_comercial

Comandos administrativos do PostgreSQL

No services do Windows eu posso acessar os comandos facilmente
pois ele tem interface gráfica com o start, stop e etc.


se o Postgre foi instalado compilado, então tenho:

Binários do PostgreSQL
- createdb (cria banco de dados por fora do cluster)
- createuser (cria user)
- dropdb     (apaga o bd)
- dropuser   (apaga o user)
- initdb      (inicia o cluster, cria coisas pra mim)
- pg_ctl      (pra controlar o banco de dados start stop)
- pg_basebackup (copia um backup de toda a estrutura)
- pg_dump / pg_dumpall (pseudobackup, pois vais extrair um 
formato de texto ou outro as infos daquele momento do banco de
dados.PG_DUMP NÃO É BACKUP)
- pg_restore(restaura os arquivos que gerei com o dump)
- psql (arquivo binário pra entrar no banco de dados via SO)
- reindexdb(fazer reindex)
- vacuumdb (reorganizar todas as tabelas)

(algum dos mais importantes)

Arquitetura/Hierarquia

Cluster
Coleção de banco de dados que compartilham as mesmas 
configurações (arquivos de configuração PostgreSQL e do SO
(porta, listen_adresses, etc)).

Banco de dados(database)
Conjunto de schemas com seus objetos/relações (tabelas,
funçõe,views, etc).

Schema
Conjunto de objetos/relações (tabelas,funçõe,views, etc).

b)Conheça a ferramenta PGAdmin


PGAdmin

Sempre que tiver problema para conectar,confira:

Importante para conexão

1. Liberar acesso ao cluster em postgresql.conf

// dia 12/07

2. Liberar acesso ao cluster para o usuário do banco de
dadis em pg_hba.cong

3. Criar/editar usuários.


local all postgres md5 (md5 em tudo)


reload - recarrega

é uma boa prática colocar comentários no bd


tuples in - inserts, deletes, updates
tuples out - o que é retornado dos comandos sql


c) Como administrar usuários no banco de dados

Conceitos users/roles/groups
Definição
Roles(papéis ou funções), users e grupo de usuários são "contas",
perfis de atuação em um banco de dados,que possuem permissões
em comum ou específicas.

Nas versões anteriores do PostgreSQL 8.1, usuários e roles tinham 
comportamentos diferentes.
Atualmente, roles e users são alias.

É possível que roles pertençam as outras roles.



ex:


administradores - professores (daniel) (robert) - alunos (Gumercindo)
(role)            (role)                          (role)



Se as roles daniel e robert estão em professores,podem escrever 
em duas tabelas e ler todas as tabelas do bd.

Gumercindo só pode ler tabelas.


Administrando users/roles/groups


CREATE ROLE name[[WITH] option[...]]

where option can be

SUPERUSER | NOSUPERUSER
| CREATEDB | NOCREATEDB
| CREATEROLE | NOCREATEROLE (a role poderá criar?)
| INHERIT | NOINHERIT (roles que pertencem a outras 
e podem herdar ou não as permissões de adm)
| LOGIN | NOLOGIN (a role pode se conectar?)
| REPLICATION | NOREPLICATION
| BYPASSRLS| NOBYPASSRLS (segurança da role)
| CONNECTION LIMIT connlimit (quntas conexões simultaneas)
| [ENCRYPTED] PASSWORD 'password'| PASSWORD NULL (encrypted ou
n, backup, restore, a senha é criptografada).
| VALID UNTIL 'timestamp' (até que data a role tem acesso ao bd)
| IN ROLE role_name [, ...] (o novo user vai pertecer a role do
in role)
| IN GROUP role_name [, ...]
| ROLE role_name [, ...] (a role que informei passará a 
pertencer ao grupo da nova role sndo criada)
| ADMIN role-name [, ...] (todas as roles q eu definir farão
parte da nova role e terão acessos administrativos)
| USER role_name [, ...] (role)
| SYSID uid

obs: criar a role superuser e usar somente quando 
necessário (casos extremos).

ex:

CREATE ROLE admin.  CREATE ROLE prof. CREATE ROLE alun.
CREATEDB            NOCREATEDB        NOCREATEDB
CREATEROLE          NOCREATEROLE      NOCREATEROLE
INHERIT             INHERIT           INHERIT
NOLOGIN             NOLOGIN           NOLOGIN    
REPLICATION         NOBYPASSRLS       NOBYPASSRLS
BYPASSRLS         CONNECTION LIMIT 10; CONNECTION LIMIT 90;  
CONNECTION LIMIT -1 

Associação entre roles
Quando uma role assume as permissões de outra role.
Necessária a opção INHERIT

No momento da criação da role:
- iN ROLE (passa a pertencer a role informada)
- ROLE (a role informada passa a pertencer a nova role)

Ou após a criação da role:
- GRANT [role a ser concedida] TO [role a assumir as permis-
_sões]

se eu quiser associar uma role a outra: INHERIT

ex:

GRANT professores TO daniel

Associação entre roles

CREATE ROLE professores
NOCRETEDB
NOCREATEROLE
INHERIT
NOLOGIN
NOBYPASSRLS
CONNECTION LIMIT -1;


CREATE ROLE daniel LOGIN CONNECTION LIMIT 1 PASSWORD '123'
IN ROLE professores;
- A role daniel passa a assumir as permissões da role 
professores.

CREATE ROLE daniel LOGIN CONNECTION LIMIT 1 PASSWORD '123'
ROLE professores;
- A role professores passa a fazer parte da role daniel assumindo
suas permissões.


CREATE ROLE daniel LOGIN CONNECTION LIMIT 1 PASSWORD '123';
GRANT professores TO daniel;

Desassociar membros entre roles
REVOKE [role que será revogada] FROM [ role que terá permissões
revogadas]

REVOKE professores FROM daniel;

Alterando uma role
ALTER ROLE role_specification [WITH] option[...]

where option can be:

SUPERUSER | NOSUPERUSER
| CREATEDB | NOCREATEDB
| CREATEROLE | NOCREATEROLE 
| CREATEUSER| NOCREATEUSER
| INHERIT | NOINHERIT 
| LOGIN | NOLOGIN 
| REPLICATION | NOREPLICATION
| BYPASSRLS| NOBYPASSRLS 
| CONNECTION LIMIT connlimit
| [ENCRYPTED] | UNENCRYPTED | PASSWORD 'password'
| VALID UNTIL 'timestamp' 

Excluindo uma role
DROP ROLE role_specification;

CREATE ROLE professores NOCREATEDB(não sou obrigada a colocar o 
nocreate)

Administrando acessos (GRANT)

Definição
São os privilégos de acesso aos objetos do banco de dados.

Privilégios:

-- tabela (especial)
-- coluna
-- sequence
-- database (especial)
-- domain
-- foreign data wrapper
-- foreign server
-- function (especial)
-- language
-- language object
-- schema (especial)
-- tablespace
-- type

DATASE
GRANT{{CREATE | CONNECT | TEMPORARY | TEMP} [, ...] | ALL PRIVILEGES]}
ON DATABASE database_name [, ...]
TO role_specification [, ...] [WITH GRANT OPTION]
13/07
SCHEMA
GRANT{{CREATE | USAGE } [, ...] | ALL PRIVILEGES]}
ON SCHEMA schema_name [, ...]
TO role_specification [, ...] [WITH GRANT OPTION]
TABLE
GRANT{{SELECT| INSERT| UPDATE| DELETE| TRUNCATE| REFERENCES| TRIGGER}
 [, ...] | ALL PRIVILEGES]}
ON {TABLE} table_name[, ...]
TO role_specification [, ...] [WITH GRANT OPTION]

legenda:
CREATE - create obj database
CONNECT - conectar
TEMPORARY, TEMP - criar objs temporários no bd
ALL PRIVILEGES - (já sabe..)

SCHEMA
CREATE - criar os objs
USAGE - utilizar os objs
PUBLIC - dá a permissão do user se conectar no bd

REVOKE (revogar)
Retira as permissões da role.

DATABASE
REVOKE[GRANT OPITION FOR]
{{CREATE | CONNECT| TEMPORARY| TEMP } [, ...] | [ALL PRIVILEGES]}
ON {DATABASE database_name [, ...]
FROM {[GROUP] role.name | PUBLIC} [, ...]  
[CASCADE | RESTRICT]

SCHEMA
REVOKE[GRANT OPITION FOR]
{{CREATE | USAGE} [, ...] | [ALL PRIVILEGES]}
ON SCHEMA schema_name [, ...]
FROM {[GROUP] role.name| PUBLIC} [, ...]  
[CASCADE | RESTRICT]

REVOGANDO TODAS AS PERMISSÕES (SIMPLIFICADO)

REVOKE ALL ON ALL TABLES IN SCHEMA [schema] FROM [role];
REVOKE ALL ON SCHEMA [schema] FROM [role];
REVOKE ALL ON DATABASE [database] FROM [role];

se eu não poder excluir uma role por ela ter muitos dependentes,
coloco os comandos de cima e aí sim o drop vai funcionar.  

d) Objetos e comandos do banco de dados

Database não compartilham objetos dentro de cada banco.
Schemas conjunto de objs dentro do bd.Tabelas,views em fim, coisas q posso 
administrar.

Database
CREATE DATABASE name
[[WITH] [OWNER [=] user_name]
   [ TEMPLATE [=] template]
   [ ENCODING [=] encoding]
   [ LC_COLLATE [=] lc_collate]
   [ LC_CTYPE [=] lc_ctype]
   [ TABLESPACE [=] tablespace_name] (onde está no disco)
   [ALLOW_CONECTIONS [=] allow_conn]
   [ CONNECTION_LIMIT [=] connlimit]
   [IS_TEMPLATE [=] istemplate ]]

ALTER DATABASE name RENAME TO new_name
ALTER DATABASE name OWNER TO {new_owner | CURRENT_USER | SESSION_USER}
ALTER DATABASE name SET TABLESPACE TO new_tablespace

DROP DATABASE[name] apagar bd


Schema
CREATE SCHEMA schema_name [AUTHORIZAION role_specification]

ALTER SCHEMA name RENAME TO new_name
ALTER SCHEMA name OWNER TO {new_owner | CURRENT-USER | SESSION USER}

DROP SCHEMA[nome]

Melhores práticas
CREATE SCHEMA IF NOT EXISTS schema_name [AUTHORIZATION role_specification] (idempotencia?)
DROP SCHEMA IF EXISTS [nome];

Exemplo de tabela:

TABELA = automovel
COLUNA 1 = (carro, moto, aviao, helicoptero)
COLUNA 2 = ano_fabricacao (2010, 2011, 2020)
COLUNA 3 = capacidade_pessoas (1, 3, 350)
COLUNA 4 = fabricante (Honda, Avianca, Yamaha)

TABELA = produto
COLUNA 1 = codigo serial do produto
COLUNA 2 = tipo (vestuário, eletronico, beleza)
COLUNA 3 = preco

Na prática:

NOME      MARCA    TAMANHO    COR
Camisa    Hering    GG        Branca
Calça     Levis     46        Preta

(claro, tem as linhas.)

Observação sobre a Primary Key:

"Não devem ser usadas chaves externas" de fato é verdade, porém
em boas práticas não seguimos as vezes,pois é opcional.


Obs: o valor não pode ser voláti/ ser alterado

PK: nome+marca+tamanho com osdados são primary key

Foreign key/FK
sempre vai referenciar a PK.

PK - número 
FK - cliente - cpf, número de série - produto

Usam a PK ID pois pode repetir o cliente, mas não o produto

Tipos de dados

Numeric Types *
Monetary Types
Character Types *
Binary Data Type
Date/Time Types *
Boolean Type *
Enumerated Types
Geometric Types
Network Adress Types
Bil String Types
Text Search Types
UUID type
XML Type
JSON Types
Arrays
Composite Types
Range Types
Domain Types
Object Identifier Types
pg_Isn Type
Pseudo-Types

* são o que usaremos

Numéricos  Storage Size...
smallint
integer
bigint
decimal
numeric
real
double precision
smallserial
serial
bigserial



Caracteres
Name                               Description
character varying(n), varchar(n)   variable-lenght with limit
character(n), char(n)              fixed-lenght, blnak padded
text                               variable unlimited lenght

diferenças entre varchar e char
varchar - sem o (n) quando eu escrever algo, ele conta "d" - 1 caracter e etc
char - sem o (n) tem um só caracter

(tabela de datas está na foto)

timezone é pra caso vc esteja fora do Brasil, por exemplo

Booleanos
Name      Storage Size    Description
boolean     1 byte         true or false

obs: modele as coisas de forma inteligente, não coloque coisas desnecessárias.


DML e DDL

DML
Data Manipulation Language
Linguagem de manipulação de dados
INSERT, UPDATE,DELETE,*SELECT*
*o select, alguns consideram como DML, outros como DQL, que significa
data language, ou linguagem de consulta de dados.

DDL
Data Definition Language
Linguagem de definição de dados
CREATE, ALTER,DROP

CREATE/ ALTER/ DROP

CREATE [objeto] [nome do objeto] [opções]; 

ALTER [objeto] [nome do objeto] [opções];

DROP [objeto] [nome do objeto] [opções];

Exemplos:
(DDL)

CREATE DATABASE dadosbancarios;
ALTER DATABASE dadosbancarios OWNER TO diretoria;
DROP DATABASE dadosbancarios;

CREATE SCHEMA IF NOT EXISTS bancos;
ALTER SCHEMA bancos OWNER TO diretoria;
DROP SCHEMA IF EXISTS bancos;

CREATE/ ALTER/ DROP - TABELAS

CREATE TABLE [IF NOT EXISTS] [nome da tabela] (
[nome do campo] [tipo] [regras] [opções],
[nome do campo] [tipo] [regras] [opções],
[nome do campo] [tipo] [regras] [opções]
);

ALTER TABLE [nome a tabela] [opções];

DROP TABLE [nome da tabela];

EIN)
CREATE TABLE IF NOT EXISTS banco (
codigo INTEGER PRIMARY KEY, 
nome VARCHAR(50) NOT NULL,
data_criacao TIMESTAMP NOT NULL DEFAULT NOW()
);

TSVEI)
CREATE TABLE IF NOT EXISTS banco (
codigo INTEGER,
nome VARCHAR(50) NOT NULL,
data_criacao TIMESTAMP NOT NULL DEFAULT NOW(),
PRIMARY KEY (codigo)
);

ALTER TABLE banco ADD COLUMN tem_poupanca BOOLEAN;

DROP TABLE IF EXISTS banco ;

ein)
Explicação:
1-Definido que o campo codigo é PK;
2- Com o NOT NULL - o campo não deve ser nulo (PRIMARY KEY também 
não,o Postgre controla e reclama).
3- DEFAULT NOW() quando eu inserir um registro nele, automaticamente
ele será preenchido com NOW (a data atual).

tsvei)
ele adiciona a coluna tem_poupanca com o booleano

INSERT

INSERT INTO [nome da tabela] ([campos da tabela])
VALUES ([valores de acordo com a ordem dos campos acima,]);

INSERT INTO [nome da tabela] ([campos da tabela,])
SELECT [valores de acordo com a ordem dos campos acima,];
(INSERT SELECT) - faz um insert na tabela comvalor de select dos dados.
É muito útil quando temos um select muito grande(com vários conjuntos de dados)
e temos que inserí-los sem ficar colocando values.

Exemplo:

INSERT INTO banco (codigo, nome, data_criacao)
VALUES (100, 'Banco do Brasil', now());

INSERT INTO banco (codigo, nome, data_criacao)
VALUES 100, 'Banco do Brasil', now();

(ambos funcionam)

UPDATE

UPDATE [nome da tabela] SET
[campo1] = [novo valor do campo1],
[campo2] = [novo valor do campo2],
...
[WHERE + condições]

ATENÇÃO: muito cuidado com os updates.Sempre utilize-os com condição.
Se eu não colocar o WHERE, farei update da tabela INTEIRA!PONHA O WHERE
-------------------------------------
Exemplo:

UPDATE bancos SET
[nome] = ['Santander']

todos os bancos se chamarão SANTANDER.
--------------------------------------
UPDATE

UPDATE banco SET
codigo = 500
WHERE codigo = 100;

UPDATE banco SET
data_criacao = now()
WHERE data_criacao IS NULL;

1- mudando o codigo dos bancos
2-data de criação nula para atual
----------------------------------------
DELETE

DELETE FROM [nome da tabela]
[WHERE + condicoes]

ATENÇÃO: muito cuidado com os deletes.Sempre utilize-os com condição.

exemplo:

DELETE FROM banco
WHERE codigo = 512;

DELETE FROM banco
WHERE nome = 'Conta Digital';
-----------------------------
SELECT

SELECT [campos da tabela]
FROM [nome da tabela]
[WHERE + condições]

DICAS DE BOAS PRÁTICAS = Evite sempre que puder o SELECT*

se tenho 100 campos na tabela, quando eu mandar o SELECT* ela trará todos
os campos, e convenhamos, nem sempre vc precisa de todos.Use o SELECT ID.
Isso é desperdíco de recurso, pesa.

Exemplo:

SELECT codigo, nome
FROM banco;

SELECT codigo, nome
FROM banco
WHERE data_criacao > ''2019-10-15 15:00:00'; (esse é específico)
========================
senha Postgres - 123
========================

Boas práticas:

ativo BOOLEAN NOT NULL DEFAULT TRUE, 

diz se o banco tá ativo ou não.

e

data_criacao TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
que funciona igual a como se tivesse o NOW() no final

INTERGER vai até 214.000.000

obs: se quero referenciar itens, eles devem ser iguais,tais quais:

 numero INTEGER NOT NULL,
 banco_numero INTEGER NOT NULL,

quais não podem se repetir:
 PRIMARY KEY (banco_numero,numero),


FOREIGN KEY (banco_numero) REFERENCES banco (numero)
diz que banco_numero é referencia a tabela banco para o campo número

boa prática: separar as tabelas por campos que eu queira ver em certos
momentos.

A ID não atende a normalização dos bancos de dados,logo, a PK pode ser 
grande.
--------------------------------------------------------------------------
ATIVIDADE:
Insira dados respeitando as pk e fk

arquivo completo DDL:

github.com/drobcosta/digital_innovation_one

3) Fundamentos da Structured Query Language (SQL)

a) Conheça o DML e o Truncate

Idempotencia: propridade que algumas ações/operações possuem possibilitando-as
de serem executadas diversas vezes sem alterar o resultadp após a aplicação
inicial;

-IF EXISTS
-Comandos pertinentes ao DDL e DML

Melhores práticas em DDL

Importante as tabelas possuírem campos que realmente serão utilizados e que sirvam de
atributo direto aum objetivo em comum.

-Criar/adicionar colunas que são "atributos básicos" do objeto;
Exemplo: tabela CLIENTE: coluna TELEFONE/ coluna AGENCIA_BANCARIA 
(ao puxar o cadastro do cliente,telefone não é algo que me interesse ver,logo,
devo colocá-lo em outra tabela.Agencia bancária não necessariamente.)O que é útil que
eu veja? Nome,cpf/cnpjn email e etc

-Cuidado com as regras (constraints); 
(quanto mais constraints, mais difícil torna updates, inserts e etc,pois tem que validar
as constraints para que seja um dado correto na tabela.)

-Cuidado com o excesso de FKs;
(não tenha muitas FKs, e se precisar criar, faça outra tabela).

-Cuidado com o tamanho indevido de colunas
Exemplo: coluna CEP VARCHAR (255)

DML - CRUD

SELECT

SELECT (campos,)
FROM tabela
[condições]

Exemplo

SELECT numero, nome FROM banco;
SELECT numero, nome FROM banco WHERE ativo IS TRUE; (posso colocar com =)
SELECT nome FROM cliente WHERE email LIKE '%gmail.com';
(com o LIKE(LIKE respeita o sensitivo) e % ele fará uma busca e trará tudo que termine com gmail.com)

SELECT numero FROM agencia
WHERE banco_numero IN (SELECT numero FROM banco WHERE nome ILIKE
'%Bradesco')
(ILIKE não respeita sensitivo, independente de estar maiúsculo ou minúsculo, 
e ele retorna as coisas para mim de qualquer forma).
Esse segundo SELECT não é recomendado pois usar o IN não é boa prática, existem
outras formas de fazer esse tipo de consulta que são muito mais inteligentes e
consumem menos recursos no BD.Quando mais inteligente for o SELECT,melhor.

SELECT - Condição (WHERE/ AND/ OR)

WHERE(coluna/condição)

- =
- >/ >=
- </ <=
- <> / !=
- LIKE
- ILIKE
- IN

Primeira condição sempre WHERE.
Demais condições, AND ou OR.
Obs: quanto melhor for a consulta, mais rápido receberei minha busca

Ex: 
SELECT coluna FROM tabela WHERE data > dezembro AND ativo = TRUE
(mais exemplos na prática)

SELECT - Idempotencia

SELECT (campos,)
FROM tabela
WHERE EXISTS(
  SELECT (campo,)
  FROM tabela2
  WHERE campo1 = valor1
  [AND/OR campoN = valorN]
);

Não é uma boa prática, embore seja tolerável usar.Melhor utilizar LEFT JOIN.

SELECT* (evitar)
(é muiiiiitooo abrangente)

INSERT

INSERT (campos da tabela,) VALUES (valores,); 
(sempre o mesmo número de recursos em cada lado)

INSERT (campos da tabela,) SELECT (valores,);
-----------------------------------------------------
INSERT - Idempotencia

INSERT INTO agencia (banco_numero,numero,nome) VALUES (341,1,'Centro da cidade');

INSERT INTO agencia (banco_numero,numero,nome)
SELECT 341,1,'Centro da cidade'
WHERE NOT EXISTS (SELECT banco_numero,numero,nome FROM agencia WHERE
banco_numero = 341 AND numero = 1 AND nome = 'Centro da cidade');
(não é boa prática, pois é muita informação)

ON CONFLICT

INSERT INTO agencia (banco_numero,numero,nome) VALUES (341,1,'Centro da cidade')
ON CONFLICT (banco_numero,numero) DO NOTHING;

se eu der um insert numa PK existente, tomo um erro.

ON CONFLICT trabalha baseado numa constrinct, e banco_numero,numero são PKs.Ele 
diz: se houver um conflito na PK, faça nada.Existem outras opções a usar, tais quais INSERT

INSERT INTO agencia (os dados) ON CONFLICT (PK) DO UPDATE
(e faco update em algum outro campo)

UPDATE

UPDATE(tabela) SET campo1 = novo_valor WHERE (condição);
JAMAIS faça update sem WHERE

DELETE

DELETE FROM (tabela) SET campo1 = novo_valor WHERE (condição);
Quer deletar a tabela inteira?Não?Então faça DELETE com condição.
-------------------------------------------------------------------
TRUNCATE

Definição
"Esvazia" a tabela.

TRUNCATE [TABLE] [ONLY] name [*] [, ...]
  RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT]
  Entre esses eu uso ou um ou outro, e o padrão é CONTINUE IDENTITY


Se eu fizer isso:

TRUNCATE [TABLE] banco CONTINUE IDENTITY
e aí limpar a tabela e add novo registro, o próximo registro é o 21.Mas eu
posso especificar RESTART IDENTITY pra 1, assim ele começa a contagem do 1 (ele
não recomenda).

RESTRICT é o padrão.Ele respeita as FKs.Se a tabela tem FKs,(por default) ele
não apaga a tabela. 
Se eu usar um CASCADE ele vai apagar tudo da tabela e se tiver referencias em 
outras tabelas ele apaga as referencias também.	 

-------------------------------------------------------------------------
TRUNCATE agencia,banco,cliente,cliente_transacoes,conta_corrente CASCADE
Primeiro comando que fiz sozinha!ORGULHO
ALTER TABLE tipo_de_transacao RENAME TO tipo_transacao
Segundo comandos
-------------------------------------------------------------------------

b) Funções agregadas em PostgreSQL

- AVG (average)
- COUNT (opção: HAVING)
- MAX
- MIN
- SUM

https://www.postgresql.org/docs/11/functions-aggregate.html








































